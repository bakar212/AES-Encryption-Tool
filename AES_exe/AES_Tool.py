# -*- coding: utf-8 -*-
"""
Created on Tue Apr 26 02:15:24 2022

@author: akhan
"""

#---------------------ENCRYPTION OPERATIONS BELOW-------------------------------------------


#lookup table for rijndael's key schedule, containg hex values of 2.pow(i-1)
#source for implemented array lookup: https://cryptography.fandom.com/wiki/Rijndael_key_schedule
rcon = [
        0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
        0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
        0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
        0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d,
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab,
        0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d,
        0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25,
        0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01,
        0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d,
        0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa,
        0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a,
        0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02,
        0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
        0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
        0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
        0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
        0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f,
        0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5,
        0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33,
        0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
        ]

#rijndael's key schedule(lookup table) of hex values for substitution of bytes 
#source for implemented array lookup: https://cryptography.fandom.com/wiki/Rijndael_S-box
sbox = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
		0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
		0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
		0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
		0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
		0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
		0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
		0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
		0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
		0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
		0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
		0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
		0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
		0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
		0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
		0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]
    
#lookup table containing hex values for operations in mixColumns(), requiring results
#for the multiplication by 2
#source for implemented array lookup: https://en.wikipedia.org/wiki/Rijndael_MixColumns
x2Table = [
    0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
    0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
    0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
    0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,	
    0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
    0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
    0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
    0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
    0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
    0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
    0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
    0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
    0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
    0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
    0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
    0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
    ]

#lookup table containing hex values for operations in mixColumns(), requiring results
#for the multiplication by 3
#source for implemented array lookup: https://en.wikipedia.org/wiki/Rijndael_MixColumns
x3Table = [
    0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
    0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
    0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
    0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
    0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
    0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
    0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
    0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,	
    0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
    0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
    0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,	
    0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,	
    0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
    0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,	
    0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
    0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
    ]



def keyExpansionCore(Bytes4, RconIndex):
    
    #rotate bytes left one place (like circular left shift)
    tempByte = Bytes4[0]#first index value copied to temp value so not to be 
    Bytes4[0] = Bytes4[1]#lost written over
    Bytes4[1] = Bytes4[2]
    Bytes4[2] = Bytes4[3]
    Bytes4[3] = tempByte

    #substitute the sbox (array) values for each of our bytes, using bytes as index for the lookup
    for i in range(4):
        Bytes4[i] = sbox[Bytes4[i]]
    
    #the first byte is to be added (bitwise hence XOR operation) to (2.pow(i-1))
    #where i is RconIndex i.e. the current round. We will use rijndael's key schdeule
    #to simplify the operation by looking up the values and adding them directly to our byte
    Bytes4[0] ^= rcon[RconIndex]

#using the 16 byte key obtained previously this function shall
#produce more keys to serve for each encryption round
def keyExpansion(key):
    
    expandedKeys = [#initialisng expndedKeys array to contain 176 values which we will soon modify
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        ]
    
    for i in range(0, 16):
        expandedKeys[i] = key[i]#the first 16 bytes will be the original key's bytes
        
    totalBytes = 16 #variable keeping track of how many bytes generated so far
    rconCount = 1#round indicator
    temp = [0,0,0,0]#temp 4 byte array to store values to be passed to keyExpansionCore
    
    while totalBytes < 176:#total 10 rounds 
        
        for x in range(len(temp)):#grabbing the last 4 bytes for every 16 bytes
                     #generated and storing them in temp
            temp[x] = expandedKeys[totalBytes - 4 + x]
        
        if totalBytes % 16 == 0:#when every every 16 byte key is generated
            keyExpansionCore(temp, rconCount)#we must perform core operation
            rconCount = rconCount + 1#increment the round count (every 16 bytes-->new round)
 #COME BACK TO THIS LINE VERY IMPOSTANT MAY REQIURE MODIFICATION!!!!
 
        for n in range(4):#finally we XOR temp bytes to starting 4 bytes of previous
        #16 bytes. The resulting 4 bytes are added to our expandedbytes
            expandedKeys[totalBytes] = expandedKeys[totalBytes-16] ^ temp[n]
            totalBytes = totalBytes + 1#increment the total bytes 
        
    return expandedKeys
    
#roundkey obtained thorugh keyExpansion() (1st round key is orignal key), 
#is added in binary to the encrypted state of message (XOR operation) 
def addRoundKey(roundkey, enc_state):
    
    for i in range(0,len(roundkey)):#loops through each byte in the state
        enc_state[i] = enc_state[i] ^ roundkey[i]#byte becomes the result
        #of binary addittion performed on the key and state byte
        
        
        
#this function substitutes the state's byte values and converts them to specific 
#hex values acording to a lookup table (s-box)
def subBytes(enc_state):
    for x in range(0,16):
        enc_state[x] = sbox[enc_state[x]]#works by using the state's byte value 
        #(in decimal) as index for sbox, ultimately becoming the sbox hex value
    
    
#shift the rows of the 16-byte block (implemented as a list)
#as required by the AES algorithm (essentially re-ordering the values
#inside the enc_state list)
def shiftRows(enc_state):
    
    temp = []#temporary list to store enc_state list values in
    #pre-determined order
    byteIndexOrder = [0,5,10,15,4,9,14,3,8,13,2,7,12,1,6,11]#index order
    #determined according to shiftRow algorithm
    
    for x in byteIndexOrder:
        temp.append(enc_state[x])#add the idexed list value from enc_state
        #to our temp list
    
    for i in range(0,16):
        enc_state[i] = temp[i]#now re-assign each value from temp
        #back to the enc_state list, to have our re-ordered list
    
#in the function below our state is multiplied with a special 4x4 matrix :
# |2 3 1 1|  this is achieved through extracting dot product result,
# |1 2 3 1|  for every state column with all the rows of the given        
# |1 1 2 3|  matrix. We use the multiplication by 2 and 3 lookup tables provided 
# |3 1 1 2|  above to simplify our calculations.
def mixColumns(enc_state):
    tempList = [] # a temporary list to store our state's new byte results
    
    #calculating the dot product results of 1st state column with every row of matrix
    #and storing in tempList
    tempList.append(x2Table[enc_state[0]] ^ x3Table[enc_state[1]] ^ enc_state[2] ^ enc_state[3])
    tempList.append(enc_state[0] ^ x2Table[enc_state[1]] ^ x3Table[enc_state[2]] ^ enc_state[3])  
    tempList.append(enc_state[0] ^ enc_state[1] ^ x2Table[enc_state[2]] ^ x3Table[enc_state[3]])
    tempList.append(x3Table[enc_state[0]] ^ enc_state[1] ^ enc_state[2] ^ x2Table[enc_state[3]])
    #calculating the dot product results of 2nd state column with every row of matrix
    #and storing in tempList
    tempList.append(x2Table[enc_state[4]] ^ x3Table[enc_state[5]] ^ enc_state[6] ^ enc_state[7])
    tempList.append(enc_state[4] ^ x2Table[enc_state[5]] ^ x3Table[enc_state[6]] ^ enc_state[7])  
    tempList.append(enc_state[4] ^ enc_state[5] ^ x2Table[enc_state[6]] ^ x3Table[enc_state[7]])
    tempList.append(x3Table[enc_state[4]] ^ enc_state[5] ^ enc_state[6] ^ x2Table[enc_state[7]])
    #calculating the dot product results of 3rd state column with every row of matrix
    #and storing in tempList
    tempList.append(x2Table[enc_state[8]] ^ x3Table[enc_state[9]] ^ enc_state[10] ^ enc_state[11])
    tempList.append(enc_state[8] ^ x2Table[enc_state[9]] ^ x3Table[enc_state[10]] ^ enc_state[11])  
    tempList.append(enc_state[8] ^ enc_state[9] ^ x2Table[enc_state[10]] ^ x3Table[enc_state[11]])
    tempList.append(x3Table[enc_state[8]] ^ enc_state[9] ^ enc_state[10] ^ x2Table[enc_state[11]])
    #calculating the dot product results of 4th state column with every row of matrix
    #and storing in tempList
    tempList.append(x2Table[enc_state[12]] ^ x3Table[enc_state[13]] ^ enc_state[14] ^ enc_state[15])
    tempList.append(enc_state[12] ^ x2Table[enc_state[13]] ^ x3Table[enc_state[14]] ^ enc_state[15])  
    tempList.append(enc_state[12] ^ enc_state[13] ^ x2Table[enc_state[14]] ^ x3Table[enc_state[15]])
    tempList.append(x3Table[enc_state[12]] ^ enc_state[13] ^ enc_state[14] ^ x2Table[enc_state[15]])

    for i in range(16):
        enc_state[i] = tempList[i] #re-assigning the new byte values from templist back
        #to the state

def encrypt(text, key):
    roundCount = 9 #AES uses 9 repeated rounds

                   #we copy first 16 words into
    state = [] #this state list, to form a 16-byte block
    
    for i in range(0, 16):
        state.append(text[i])#copy first 16 bytes into new list
    
    
    #inital encryption stage
    roundKeys = keyExpansion(key)#obtains the expanded byte array (every 16 bytes --> new round key)
    
    #below is the same implentation for addRoundKey() method with modification
    #this serves as the first addRoundKey stage
    for i in range(0,len(key)):#loops through each byte in the state
        if isinstance(state[i],int):#if the byte is an integer then
            state[i] = state[i] ^ key[i]#then we perform XOR without converting to ASCII
        else:#otherwise conversion to ascii is required first for other characters
            state[i] = ord(state[i]) ^ key[i]#byte becomes the result
        #of binary addittion performed on the key and state byte
        
    #main stage where operation is repeated a number of times
    for i in range(0, roundCount):
        subBytes(state)
        shiftRows(state)
        mixColumns(state)
        
        startIndex = (i+1)*16 #index values to obtain every 16 byte key from roundKeys[]
        endIndex = startIndex+16#the first 16 bytes are skipped as this has already been used
        
        addRoundKey(roundKeys[startIndex:endIndex],state)
        
    #final encryption stage (identical to repeated stage,
    #except for one skipped function)    
    subBytes(state)
    shiftRows(state)
    addRoundKey(roundKeys[160:176],state)#obtains final round keys


    cipherText = state #final encrypted message

    return cipherText 



#-------------------------DECRYPTION OPERATIONS BELOW---------------------------------
#from Cryptodome.Cipher import AES   

#def decrypt(cipherText, key):
#       cipher = AES.new(key, AES.MODE_ECB)
 #      decryptedMessage = cipher.decrypt(cipherText)
  #     print(decryptedMessage.decode('UTF-8'))


#------------------MAIN OPERATIONS PERFORMED BELOW---------------------------------- 
from numpy import random
import os


#function adjusts length of message to a multiple of 16, all extra empty bytes 
#are then padded with 0's
def padMessage(text):
    textList = list(text)#passed in text message to be converted
    #to a list of characters to perform some further operations
    
    origLength = len(textList)#original length
    
    if origLength % 16 != 0:#if message legth is not a multiple of 16
        adjustedLength = origLength - (origLength % 16) + 16#then adjust
        #with a new multiple of 16 length    
    
        newTextList = []#new list containng bytes with padded 0's at end 
        
        for i in range(adjustedLength):
            if i >= origLength:#pad remaing bytes with 0's where the orignal message
                newTextList.append(0)#length ends
            else:
                newTextList.append(textList[i])#rest of the message to be copied 
        
        return newTextList#return padded list
    
    return textList#othewise return original list as no need to pad
                         

text = input('PLEASE ENTER THE TEXT MESSAGE YOU WISH TO ENCRYPT: \n')
#text = 'jibewiufbadiofbaiudfbiuaebsfiuasdb bviuasdbviuabsdvuibisd vihsd'
result = padMessage(text)

print(''''\nNOW PLEASE ENTER THE 16 BYTE KEY, MAKE SURE YOUR KEY BYTE VALUES ARE 
      BETWEEN 0-255, PRESS ENTER EACH TIME YOU INPUT A KEY BYTE\n''')

key = []

for i in range(16):
    byte = int(input('Enter key byte: '))
    
    if byte <= 255:#a byte value can have a max value of 255
        key.append(byte)
    else:
        print('FATAL ERROR! byte size must have a value between 0-255')
        print('Program will apply random byte value instead!\n')#error handling
        key.append(random.randint(255))#manual assignment of random int

print('\nYour key: ',key)

encryptedtext = []

#as the message may consist of more than 16 bytes, we will run encrypt function
#for the remaing bytes via a loop
for i in range(0,len(result),16):#incerment by 16 (16 bytes)
    encryptedtext = encryptedtext + encrypt(result[i:i+16], key)#encrypts sections 
    #(every 16 elements/bytes) of the padded message with every loop
    
for i in range(len(encryptedtext)):#convert every value to the specified (lowercase)
    encryptedtext[i] = format(encryptedtext[i], 'x')#hexadecimal format

print('\nRESULT: ',encryptedtext)

saveResult = int(input('\nIf you wish to save your results please input 1 and enter...'))

if saveResult == 1:#ensures user hit right key 
   
    str = ''

    for byte in encryptedtext:
        str = str + byte       #concatenate the list of hex values to text
    
    filename = input("\nPlease name the file and then press enter...")
    filename = filename + '.txt' #.txt extension neccessary for text files
    
    if os.path.exists('encryptedResults') == False:#only create a directory for
        os.makedirs('encryptedResults')#encrypted results if the directory doesn't already exist
    
    file = open('encryptedResults/'+filename,"w")
    file.write(str)  #writes the string ciphertext
    file.close()     #important to close file
    
    print('''\n THE FILE HAS SUCCESSFULLY BEEN SAVED IN THE SUBFOLDER CALLED
          encryptedResults LOCATED IN YOUR WORKING DIRECTORY !''')

    input('\n PRESS ANY KEY TO EXIT THE PROGRAM...')













